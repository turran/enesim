Enesim
======
+ We should add a way to get the backend data from a renderer or surface. This is useful for
  cases like the glx example where we need a way to render the texture inside a surface into
  the final framebuffer. Another useful case might be on the future for a new way to define
  renderers or extend them. Instead of calling the enesim_renderer_setup() as is, we might
  want to get the backend data and manage that data directly
+ Add a pattern renderer. Basically it should just draw another renderer inifinitely, of course
 if we want to restrict it to a specific area, then we should use a clipper? or maybe make the
 pattern clip also?
+ Make use of the flags on the surface draw function
+ We need to optimize and avoid the need to always call
  enesim_renderer_data_get(r) whenever we want to render a span, for such, extend such function
  to receive the data already fetch with enesim_renderer_data_get(r) but on the surface_draw
+ Change very renderer to use *thiz* as the variable for itself
+ We need to get rid of the hypot function, it is used on a lot places
  but with f16p16 values
+ We need to use the real types on the rendering functions
+ We need to simplify the real rendering functions into its own
  c file with its own struct, this way in the future we can reuse the
  algorithm for other backends
+ Split the hswitch and transition common parts into a common transition renderer
  with properties as src, target and step, that's all
+ This one is important, is time to worry about the memory, given that renderers can go inside others
  and so forth, why not instead of doing enesim_delete we do enesim_ref/unref, this might do our lifes
  easier
  already done:
  other/compound
  other/clipper
  shape/shape
  transition/transition
+ Normalize the stride/pitch
+ Initialize every renderer to some sane vales
+ We need to use whenever possible functions for fixed point operations. This way later we can just
  create some #defines for them and we can easily change from 16.16 to 32.32 or stuff like that
+ The renderers should implement or even the change interface or the damage, there's no need to iterate
  the rendernig tree twice, one for the change callback and another for the damage callback
+ If we do the above then we should remove the enesim_renderer_has_changed API function, it should just
  request the damages. If no damages, then no change, etc. Or implement the changed as a call to damages
  with a simple callback that whenever a some damage area is returned then we should just abort and return
  true
+ Later we'll need some kind of locking on the surface

Emage
=====
+ Make the load/save functions receive the Emage_Data (the data abstraction: file, buffer, whatever)
+ Right now we support loading/saving files by doing
  emage_load(file, surface, options)
  and the providers have this interface:

typedef struct _Emage_Provider
{
	const char *name;
	Emage_Provider_Type type;
	void * (*options_parse)(const char *options);
	void (*options_free)(void *options);
	/* TODO also pass the backend, pool and desired format? */
	Eina_Bool (*loadable)(const char *file);
	Eina_Bool (*saveable)(const char *file);
	Eina_Error (*info_get)(const char *file, int *w, int *h, Enesim_Buffer_Format *sfmt, void *options);
	Eina_Error (*load)(const char *file, Enesim_Buffer *b, void *options);
	Eina_Bool (*save)(const char *file, Enesim_Surface *s, void *options);
} Emage_Provider;

That means that when we load a file, the path is actually passed to the providers as is and it decides
if the file is loadable (usually by getting the extension of the path and returning TRUE/FALSE)
Then the info is loaded and finally the real load. What we need to do is to abstract all the IO and just
normalize the way providers fetch the data. Currently it means three fopen, fread, etc. What we can do is
that the IO is abstracted on emage itself i.e:

emage_load(file, surface, options)
emage_load_data_from(data, data_length, mimetype, surface, options)
emage_load_base64_from(base64_data, data_length, mimetype, surface, options)
emage_load_foo_from(foo ....)

Then the providers api should actually be as a first parameter pass the data instead of the file path
Then the emage core lib should have a way to match a extension to a mime type and also change the loadable to receive
the mimetype instead of the file. Maybe later add more specific api functions on the provider to detect the file
i.e a type finder based on some data, like the magic number on the raw data

Etex
====
+ Add fontconfig support
+ Add a path-follow-span, i.e a text span that can receive
  a shape and use that as the path to follow. We need more
  code on enesim to know whenever a renderer is of a specific
  type, similar to what we are doing on eon
+ Add rich text element

